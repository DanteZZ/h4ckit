<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../styles/style.css">

<div id="screen"></div>

<script>
	function onmsg(event) {
		if (event.data.setpid) {
			global._pid = event.data.pid;
			global._poster = event.source;
			cmd._setVM({_pid:event.data.pid});
			cmd._setPoster(event.source);
			global.pidset = true;
		} else if (global.pidset) {
			cmd._onMessage(event.data.data);
		}
	};
	
	const vm = require("vm");
	delete require.cache[require.resolve("./commands.js")];
	const cmd = require("./commands.js");
	global.__csl = console;
	ctx = {};
	vmthreads = {};

	window.addEventListener("message", onmsg, false);

	window._SCREEN = document.getElementById("screen");
	
	class ELEMENT {
		#src = null
		events = {}
		constructor(tag) {
			this.#src = document.createElement(tag);
		}

		listEvent(event,func) {
			if (typeof this.events[event] !== "undefined") {
				this.#src.removeEventListener(event,this.events[event]);
			}

			this.events[event] = function(e) {func(e)};
			this.#src.addEventListener(event,this.events[event]);
		}

		unlistEvent(event) {
			if (typeof this.events[event] !== "undefined") {
				this.#src.removeEventListener(event,this.events[event]);
			}
			delete(this.events[event]);
		}

		setStyles(style) {
			for (const property in style)
			this.#src.style[property] = style[property];		
		}

		putElement(el) {
			this.#src.appendChild(el._getNode());
		}

		putHtml(data) {
			this.#src.innerHTML = data;
		}

		putText(data) {
			this.#src.innerText = data;
		}

		_getNode() {
			return this.#src;
		}

		getParam(param) {
			return this.#src[param];
		}
		setParam(param,val) {
			this.#src[param] = val;
		}

		focus() {
			this.#src.focus();
		}

		blur() {
			this.#src.blur();
		}

		setAttribute(a,b) {return this.#src.setAttribute(a,b);}
	}
	
	class _gl {
		constructor(width,height) {
			this._screen =_SCREEN;
		}
		createElement = (tag) => new ELEMENT(tag)
	}

	const vmFuncs = { // Функции общения с железом
		sendCommand: function(command,data={},callback=false,ctx=null) {return cmd._sendCommand(command,data,callback,ctx);},
		sendLog: function(data) {return cmd._sendLog(data);},
		sendError: function(data) {return cmd._sendError(data);},
		sendEvent: function(event,data=false) {return cmd._sendEvent(event,data);},
		
		regCommand: function(command,func,ctx=false,async=false){return cmd._reg(command,func,ctx,async)},
		regCat: function(name){return cmd._regCat(command,func,ctx,async)},

		listenEvent:function(event,func = ()=>{},ctx=null){return cmd._listenEvent(event,func,ctx)},
		unlistenEvent:function(id){return cmd._unlistenEvent(id)},
		doEvent:function(event,data=false){return cmd._doEvent(event,data)},

		runScript:function(script) {vm.runInContext(script,ctx);},
	};

	const threadFuncs = {
		mk:function(ctx) {return  vm.createContext(ctx); },
		runScript:function(ctx,script) { try {vm.runInContext(script,ctx); return true;} catch (e) {return e;} }
	}

	function _regDefaultCommands() { // Регистрация команд устройства
		cmd._regCat("vm");
		cmd._reg("vm/setCTX",function(d) {
			ctx = d.context;
			ctx.Math = Math;
			ctx.setInterval = setInterval;
			ctx.setTimeout = setTimeout;
			ctx.__gl = _gl;
			ctx.__vm = vmFuncs;
			ctx.__thread = threadFuncs;
			ctx.global = {};
			ctx.console = __csl;
			ctx = vm.createContext(ctx);
			return true;
		});
		cmd._reg("vm/runScript",function(d) {
			if ((ctx) && (d.script)) { // Если контекст не пустой
				try {
					vm.runInContext(d.script,ctx);
				} catch (e) {
					cmd._sendError(e);
				};
				return true;
			} else {
				return false;
				cmd._sendError("Context/Script error");		
			};
		});
	};
	_regDefaultCommands();

</script>