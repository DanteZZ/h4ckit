___k.PROC = {
	list:[],
	init: async function(path,attrs, isHup = true) { // Запустить процесс
		const id = this.randomId();
		const process = new __PROCESS(id,path,attrs);
		this.list.push({ id, process });
		process.setHupMode(isHup);
		await process.init();
		return process;
	},
	destroy:function(id) {
		const ind = this.list.findIndex((e,i)=>e.id === id);
		if (ind !== undefined) {
			this.list.splice(ind,1);
		}
	},
	randomId:function () {
		let rand = 1000 - 0.5 + Math.random() * (2000 - 1000 + 1);
		return Math.round(rand);
	}
};

__PROCESS = class {
	ctx = null;
	#id = null;

	constructor(id,path,attrs) {
		this.#id = id;
		let ctx = {
			_import:___k.importLibrary,
			_os:___k.getOSCtx(),
			_process: {
				send: (str)=>__CLI.printLn(str),
				exit: ()=>this.destroy(),
				setHupMode: (a)=>this.ctx._process.__hupMode=a,
				hupMode: ()=>this.ctx._process.__hupMode,
				getScreenOwn: ()=>{
					const res = __CLI.setScreenOwner(this);
					return res ? {setScreen:(screen)=>__CLI.setScreen(this,screen)} : false
				},
				__hupMode:true,
				__id: id,
				__attributes: attrs,
				__path: path
			}
		};
		this.ctx = __thread.mk(ctx);
	}

	isHup() {return this.ctx._process.__hupMode }
	setHupMode(a) {this.ctx._process.__hupMode=a }

	async init() {
		const ee = await ___k.importLibrary("libs/eventEmmiter");
		this.$EE = new ee;
		const script = await ___k.FS.readFile(this.ctx._process.__path);
		__thread.runScript(this.ctx,script);
	}

	listEvent(a,b) {return this.$EE.on(a,b)}
	unlistEvent(a,b) {return this.$EE.removeListener(a,b)}

	run() {
		return this.ctx._initialize();
	}

	useScreen(proc) { return this.ctx?._screenOwnHandler ? this.ctx?._screenOwnHandler(proc) : false }

	async destroy() {
		this.$EE.emit("exit");
		___k.PROC.destroy(this.#id);
	}
}