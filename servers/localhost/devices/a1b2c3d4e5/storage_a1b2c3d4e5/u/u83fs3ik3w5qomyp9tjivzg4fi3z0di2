___k.PROC = {
	list:[],
	init: async function(cli=null,path,attrs, isHup = true) { // Запустить процесс
		const id = this.randomId();
		const process = new __PROCESS(id,path,attrs, cli);
		this.list.push({ id, process });
		process.setHupMode(isHup);
		await process.init();
		return process;
	},
	clearInit: async function(path,attrs,isHup) {return await this.init(null,path,attrs,isHup)},
	destroy:function(id) {
		const ind = this.list.findIndex((e,i)=>e.id === id);
		if (ind !== undefined) {
			this.list.splice(ind,1);
		}
	},
	randomId:function () {
		let rand = 1000 - 0.5 + Math.random() * (2000 - 1000 + 1);
		return Math.round(rand);
	}
};

__PROCESS = class {
	ctx = null;
	#id = null;

	constructor(id,path,attrs, cli=null) {
		this.#id = id;
		let ctx = {
			_import:___k.importLibrary,
			_os:___k.getOSCtx(),
			_process: {
				std: {
					write: (a)=>this.$EE.emit("stdout",a),
					read: (a) => { // Ловец ввода сообщений, возвращающий ремувер
						this.listEvent("stdin",a)
						return ()=>{ this.unlistEvent("stdin",a) }
					},
					clear: cli ? cli.clear : ()=>{},
					_cli: {
						run: (command,attributes) => cli ? cli?.runCommand(command,attributes) : ()=>{},
						setPath:(p)=>cli ? cli.setPath(this,p) : ()=>{}
					}
				},
				$path: cli ? cli.$PATH : "/",
				exit: ()=>this.destroy(),
				setHupMode: (a)=>this.ctx._process.__hupMode=a,
				hupMode: ()=>this.ctx._process.__hupMode,
				getOutOwn: ()=>{
					const res = __CLI.setOwner(this);
					return res ? { screen: {setScreen:(screen)=>__CLI.setScreen(this,screen)}, CLI: cli } : false
				},
				__hupMode:true,
				__id: id,
				__attributes: attrs,
				__path: path
			}
		};
		this.ctx = __thread.mk(ctx);
	}

	getId() {return this.#id}

	isHup() {return this.ctx._process.__hupMode }
	setHupMode(a) {this.ctx._process.__hupMode=a }

	async init() {
		const ee = await ___k.importLibrary("libs/eventEmmiter");
		this.$EE = new ee;
		const script = await ___k.FS.readFile(this.ctx._process.__path);
		__thread.runScript(this.ctx,script);
	}

	listEvent(a,b) {return this.$EE.on(a,b)}
	unlistEvent(a,b) {return this.$EE.removeListener(a,b)}

	onStdOut(a) { // Ловец вывода сообщений, возвращающий ремувер
		this.listEvent("stdout",a)
		return ()=>{ this.unlistEvent("stdout",a) }
	}

	stdIn(a) { // Ввод сообщений
		this.$EE.emit("stdin",a);
	}

	run() {
		return this.ctx._initialize();
	}

	useScreen(proc) { return this.ctx?._screenOwnHandler ? this.ctx?._screenOwnHandler(proc) : false }

	async destroy() {
		if (this?.ctx?._exiting) {
			await this?.ctx?._exiting();
		};
		this.$EE.emit("destroy");
		this.$EE.emit("exit");
		___k.PROC.destroy(this.#id);
	}
}