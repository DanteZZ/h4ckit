//----------------------
// Load Kernel functions
//----------------------

const ___ctx = this;
const { _screen, createElement } = new __gl();
class _kernel {
	#_cmd_queue = []; // Очередь на выполнение команд
	#_vars = {
		paths: ["bin"],
		init:"shell"
	};
	getVar(a) {
		return this.#_vars[a];
	};
	setVar(a,b) {
		return this.#_vars[a] = b;
	};
	getOSCtx() {
		return {...___ctx,__gl:{ createElement }};
	};
	initScript = (path, vol) => new Promise ((res,rej)=> {
		__vm.sendCommand("interfaces/storage/"+(vol || __boot.storage)+"/readdata",{path},(d) => {
			if (d !== false) {
				__vm.runScript(d);
				res();
			} else {
				rej("Undefined script: "+path);
				__vm.sendError("Undefined script: "+path);
			};
		})
	});
	importLibrary = (path,_imports={}, vol) => new Promise((res,rej) => {
		__vm.sendCommand("interfaces/storage/"+(vol || __boot.storage)+"/readdata",{path},(d) => {
			if (d !== false) {
				const ctx = __thread.mk({_os:this.getOSCtx(), exports:undefined, _imports, __waitExport:true, _import: ___k.importLibrary});
				try {
					__thread.runScript(ctx,d);
				} catch (e) {
					rej(e);
				}
				res(ctx.exports());
			} else {
				rej("Undefined module: "+path);
				__vm.sendError("Undefined module: "+path);
			};
		})
	})
}

const ___k = new _kernel();
const initModules = async () => {

	___k.FS = await ___k.importLibrary("libs/fs");
	___k.EE = await ___k.importLibrary("libs/eventEmmiter");
	await ___k.initScript("sbin/shell");
	await ___k.initScript("kernel/proc");
	const cli = await ___k.PROC.init("sbin/cli",[],false);
	cli.run();
	
}

initModules();

mouse_x = 0;
mouse_y = 0;

__vm.listenEvent("interfaces/mouse/mouse_a1b2c3d4e5/move",function(d){
	mouse_x = d.x;
	mouse_y = d.y;
});