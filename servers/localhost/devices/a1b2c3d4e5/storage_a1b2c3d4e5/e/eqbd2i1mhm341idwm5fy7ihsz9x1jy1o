class _SHELL {
    #SCREEN_OWNER = null;
    constructor() {
        this.$HISTORY = [];
        this.$PRINT = [];
        this.$PATHS = ["bin/", "sbin/"];
        this.$EVENT = new ___k.EE(this);
        this.$PATH = "/";
        this.$PCNAME = "pc";
        this.$RUNNING = null;
    }

    listEvent = (a,b) => this.$EVENT.on(a,b)
    unlistEvent = (a,b) => this.$EVENT.removeListener(a,b)
    setPath = (path) => {this.$PATH = path; this.$EVENT.emit("update");}
    setScreenOwner = (proc) => {
        const res = !this.#SCREEN_OWNER ? true : this.#SCREEN_OWNER.useScreen(proc);
        if (res) {
            this.#SCREEN_OWNER = proc;
            this.#SCREEN_OWNER.listEvent("destroy",()=>{ this.#SCREEN_OWNER = null });
            return true;
        };
        return false;
    }
    scr = () => this.#SCREEN_OWNER
    setScreen = (proc,screen) => {
        if (proc == this.#SCREEN_OWNER) {
            _screen.innerHTML = "";
            _screen.appendChild(screen);
        }
    }
    async runCommand(command,attributes=[]) {
        const str = attributes.length > 0 ? command + " " + attributes.join(" ") : command
        this.printLn(str);
        this.$HISTORY.push(str);

        const exec = await this.searchExec(command);
        
        if (exec) {
            const proc = await ___k.PROC.init(exec,attributes);
            
            if (proc.isHup()) {
                if (!this.$RUNNING) { this._setRunning(proc); };
                try {
                    await proc.run();
                    this._setRunning(null);
                } catch (e) {
                    this.printLn(e?.toString() || "Unknown Error");
                }
            } else {
                proc.run();
            }
        } else {
            this.printLn("Unknown command");
        }
    };

    _setRunning(a) {
        this.$RUNNING = a;
        this.$EVENT.emit("update");
    }

    abort() {
        this._setRunning(null);
    }

    printLn(string) {
        this.$PRINT.push(string);
        this.$EVENT.emit("update");
    }

    clear() {
        this.$PRINT = [];
        this.$EVENT.emit("update");
    }

    async searchExec(name) { // Поиск исполняемого файла
        let find = false;
        const paths = [this.$PATH,...this.$PATHS];
        for (var k in paths) {
            const path = paths[k]+name;
            const attrs = await ___k.FS.getAttributes(path);
            if (attrs?.exec) {
                find = path;
                break;
            };
        };
        
        return find;
    }

}

__CLI = new _SHELL();